{
    "version": "https://jsonfeed.org/version/1",
    "title": "星祤书架 • All posts by \"编程\" category",
    "description": "游戏更新 & 编程笔记",
    "home_page_url": "https://byx.vercel.app",
    "items": [
        {
            "id": "https://byx.vercel.app/note/program/ide/add_vscode_to_the_right_click_menu/",
            "url": "https://byx.vercel.app/note/program/ide/add_vscode_to_the_right_click_menu/",
            "title": "添加 vscode 到右键菜单",
            "date_published": "2019-09-23T15:03:39.000Z",
            "content_html": "<p><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Windows Registry Editor Version <span class=\"token number\">5.00</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>*<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"用 Visual Studio Code 打开\"</span>\n<span class=\"token string\">\"Icon\"</span><span class=\"token operator\">=</span><span class=\"token string\">\"%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe\"</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>*<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">\\</span>command<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%1<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span>\n\nWindows Registry Editor Version <span class=\"token number\">5.00</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>Directory<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"用 Visual Studio Code 打开\"</span>\n<span class=\"token string\">\"Icon\"</span><span class=\"token operator\">=</span><span class=\"token string\">\"%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe\"</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>Directory<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">\\</span>command<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%V<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span>\n\nWindows Registry Editor Version <span class=\"token number\">5.00</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>Directory<span class=\"token punctuation\">\\</span>Background<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"用 Visual Studio Code 打开\"</span>\n<span class=\"token string\">\"Icon\"</span><span class=\"token operator\">=</span><span class=\"token string\">\"%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe\"</span>\n\n<span class=\"token punctuation\">[</span>HKEY_CLASSES_ROOT<span class=\"token punctuation\">\\</span>Directory<span class=\"token punctuation\">\\</span>Background<span class=\"token punctuation\">\\</span>shell<span class=\"token punctuation\">\\</span>VSCode<span class=\"token punctuation\">\\</span>command<span class=\"token punctuation\">]</span>\n@<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%localappdata%<span class=\"token entity\" title=\"\\\\\">\\\\</span>Programs<span class=\"token entity\" title=\"\\\\\">\\\\</span>Microsoft VS Code<span class=\"token entity\" title=\"\\\\\">\\\\</span>Code.exe<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>%V<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "IDE"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/computer_science/all_modes_of_raid_are_explained-in-detail/",
            "url": "https://byx.vercel.app/note/computer_science/all_modes_of_raid_are_explained-in-detail/",
            "title": "RAID所有模式详解",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<h1 id=\"目录\"><a class=\"anchor\" href=\"#目录\">#</a> 目录</h1>\n<ul>\n<li><code>RAID 0</code></li>\n<li><code>RAID 1</code></li>\n<li><code>RAID 3</code></li>\n<li><code>RAID 3 + Spare</code></li>\n<li><code>RAID 5</code></li>\n<li><code>RAID 5 + Spare</code></li>\n<li><code>RAID 6</code></li>\n<li><code>RAID 0 + 1</code></li>\n<li><code>RAID 10</code></li>\n<li><code>串联</code></li>\n<li><code>JBOD</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-0\"><a class=\"anchor\" href=\"#raid-0\">#</a> RAID 0</h1>\n<h4 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 0</code>  是  <code>速度最快</code>  的一种  <code>RAID 模式</code></li>\n<li><code>RAID 0</code>   <code>至少需要两个磁盘</code> ，并且会将  <code>数据分条到每个磁盘</code></li>\n<li><code>所有磁盘的可用容量合在一起</code> ，成为计算机上的 <code>一个逻辑卷</code></li>\n<li>如果  <code>一个磁盘发生故障</code> ， <code>所有磁盘的数据</code>  都将  <code>不可访问</code> ，因为  <code>数据分条到每个磁盘</code>  里了</li>\n</ul>\n<h4 id=\"应用\"><a class=\"anchor\" href=\"#应用\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 0</code>  是要求  <code>最高速度</code>  和  <code>最大容量</code>  的  <code>理想选择</code></li>\n<li>要  <code>处理超大型文件的视频编缉</code>  可以使用  <code>RAID 0</code>  来编辑视频的多个流，以达到  <code>最佳播放效果</code>  和  <code>最快导出效果</code></li>\n<li><code>RAID 0</code>  阵列  <code>更适于在频繁的文件处理</code>  中使用， <code>不宜用作唯一的存储备份解决方案</code> ，也  <code>不宜在关键任务系统中使用</code></li>\n</ul>\n<h4 id=\"读写速度\"><a class=\"anchor\" href=\"#读写速度\">#</a> 读写速度：</h4>\n<ul>\n<li><code>RAID 0 读写速度</code>  =  <code>磁盘数</code>  x  <code>磁盘读写速度</code></li>\n</ul>\n<h4 id=\"容量\"><a class=\"anchor\" href=\"#容量\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 0 可用容量</code>  =  <code>磁盘数</code>  x  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-1\"><a class=\"anchor\" href=\"#raid-1\">#</a> RAID 1</h1>\n<h4 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 1</code>  是一种  <code>安全</code>  的  <code>RAID 模式</code></li>\n<li><code>RAID 1</code>   <code>至少需要两个磁盘</code> ，并且磁盘成对计算机上将安装  <code>一个逻辑卷</code></li>\n<li><code>两个磁盘</code>  合并后的  <code>可用容量</code>  限制为  <code>最小磁盘的容量上限</code></li>\n<li>如果  <code>一个磁盘出现故障</code> ，可以立即从  <code>第二个磁盘上获取数据</code></li>\n<li>即使  <code>一个磁盘出现故障</code> ，也  <code>不会丢失任何数据</code></li>\n</ul>\n<h4 id=\"应用-2\"><a class=\"anchor\" href=\"#应用-2\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 1</code>  可提供  <code>最高的数据安全性</code> ，但由于  <code>数据需写入两次</code> ，因此在  <code>写入时性能会略有下降</code></li>\n<li>在  <code>更注重安全性而非速度</code>  的情况下， <code>RAID 1</code>  是  <code>理想选择</code></li>\n</ul>\n<h4 id=\"读写速度-2\"><a class=\"anchor\" href=\"#读写速度-2\">#</a> 读写速度：</h4>\n<ul>\n<li><code>RAID 1 读写速度</code>  ≤  <code>磁盘数</code>  x  <code>读写速度</code>  /  <code>磁盘数</code></li>\n</ul>\n<h4 id=\"容量-2\"><a class=\"anchor\" href=\"#容量-2\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 1 可用容量</code>  ≤  <code>磁盘数</code>  x  <code>磁盘容量</code>  /  <code>2</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-3\"><a class=\"anchor\" href=\"#raid-3\">#</a> RAID 3</h1>\n<h4 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 3</code>  使用  <code>字节级别的条带化</code>  技术</li>\n<li><code>RAID 3</code>  采用  <code>专用的奇偶校验磁盘</code> ，因此计算机上会安装  <code>一个逻辑卷</code></li>\n<li><code>RAID 3</code>  阵列能在  <code>一个磁盘出现故障</code>  的情况下  <code>确保数据不丢失</code></li>\n<li>如果  <code>一个磁盘出现故障</code> ，该磁盘上的  <code>数据可以重建到更换磁盘上</code></li>\n<li>如果  <code>数据尚未重建到更换磁盘上</code> ，而此时  <code>又有一个磁盘出现故障</code> ，那么阵列中的  <code>所有数据都将丢失</code></li>\n</ul>\n<h4 id=\"应用-3\"><a class=\"anchor\" href=\"#应用-3\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 3</code>  在要  <code>读取连续的长文件</code> （如：视频文件）的环境中  <code>可提供良好的数据安全性</code></li>\n<li>由于数据是从  <code>奇偶校验块中读取</code> ，因此  <code>磁盘故障不会导致服务中断</code></li>\n<li><code>RAID 3</code>  适用于  <code>追求性能并要求持续访问数据</code> （如：视频编辑）</li>\n<li>对于  <code>密集使用不连续文件</code>  来说， <code>RAID 3</code>  并  <code>非理想之选</code> ，因为  <code>专用的奇偶校验磁盘</code>  会影响  <code>随机读取性能</code></li>\n</ul>\n<h4 id=\"读写速度-3\"><a class=\"anchor\" href=\"#读写速度-3\">#</a> 读写速度：</h4>\n<ul>\n<li><code>RAID 3 读写速度</code>  ≤ (  <code>磁盘数</code>  -  <code>1</code>  ) x  <code>磁盘读写速度</code>  /  (  <code>磁盘数</code>  -  <code>1</code>  )</li>\n</ul>\n<h4 id=\"容量-3\"><a class=\"anchor\" href=\"#容量-3\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 3 可用容量</code>  = (  <code>磁盘数</code>  -  <code>1</code>  ) x  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-3-spare\"><a class=\"anchor\" href=\"#raid-3-spare\">#</a> RAID 3 + Spare</h1>\n<h4 id=\"介绍-4\"><a class=\"anchor\" href=\"#介绍-4\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 3 + Spare</code>  模式下，阵列中会有  <code>一个磁盘保持空置状态</code></li>\n<li>如果  <code>一个磁盘出现故障</code> ，故障磁盘中的数据就会  <code>自动重建到空磁盘（备用磁盘）上</code></li>\n</ul>\n<h4 id=\"应用-4\"><a class=\"anchor\" href=\"#应用-4\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 3 + Spare</code>  模式下， <code>磁盘故障不需要立即处理</code></li>\n<li><code>RAID 3 + Spare</code>  会使用  <code>热备用磁盘对自己进行重建</code> ，但  <code>故障磁盘还是应尽快更换</code></li>\n</ul>\n<h4 id=\"容量-4\"><a class=\"anchor\" href=\"#容量-4\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 3 + Spare 可用容量</code>  = (  <code>磁盘数</code>  -  <code>2</code>  ) *  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-5\"><a class=\"anchor\" href=\"#raid-5\">#</a> RAID 5</h1>\n<h4 id=\"介绍-5\"><a class=\"anchor\" href=\"#介绍-5\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 5</code>  综合了  <code>RAID 0</code>  的  <code>条带化技术</code>  以及  <code>阵列数据冗余技术</code></li>\n<li><code>RAID 5</code>   <code>至少需要三个磁盘</code></li>\n<li><code>RAID 3</code>  和  <code>RAID 5</code>  的区别： <code>RAID 3</code>  配置提供的  <code>性能更高</code> ，但  <code>总容量略低</code></li>\n<li>数据会在  <code>所有磁盘之间分条</code> ，并且  <code>每个数据块的奇偶校验块 (P) 写入到同一条带上</code></li>\n<li>如果  <code>一个磁盘出现故障</code> ，该磁盘上的数据  <code>可以重建到更换磁盘上</code></li>\n<li>出现故障时， <code>数据不会丢失</code> ，但如果  <code>数据尚未重建到更换磁盘上</code> ，而此时  <code>又有一个磁盘出现故障</code> ，阵列中的  <code>所有数据都将丢失</code></li>\n</ul>\n<h4 id=\"应用-5\"><a class=\"anchor\" href=\"#应用-5\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 5</code>  综合考虑了  <code>数据安全</code>  和  <code>磁盘空间充分利用</code>  这两方面的因素</li>\n<li>由于数据是从  <code>奇偶校验块中读取</code> ，因此  <code>磁盘故障不会导致服务中断</code></li>\n<li><code>RAID 5</code>  适用于  <code>归档</code> ，且  <code>适合追求性能并要求持续访问数据</code> （如：视频编辑）</li>\n</ul>\n<h4 id=\"容量-5\"><a class=\"anchor\" href=\"#容量-5\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 5 可用容量</code>  = (  <code>磁盘数</code>  -  <code>1</code>  ) *  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-5-spare\"><a class=\"anchor\" href=\"#raid-5-spare\">#</a> RAID 5 + Spare</h1>\n<h4 id=\"介绍-6\"><a class=\"anchor\" href=\"#介绍-6\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 5 + Spare</code>  是一种  <code>RAID 5</code>  阵列，其中有  <code>一个磁盘用作备用磁盘</code> ，用于在  <code>磁盘发生故障时立即重建系统</code></li>\n<li><code>RAID 5 + Spare</code>   <code>至少需要四个磁盘</code></li>\n<li>如果  <code>一个磁盘发生故障</code> ，磁盘上的  <code>数据仍然可以访问</code> ，因为数据是  <code>从奇偶校验块</code>  中读取的</li>\n<li>故障磁盘上的数据  <code>将重建到热备用磁盘上</code></li>\n<li>当  <code>故障磁盘更换后</code> ， <code>更换的磁盘便成为新的热备用磁盘</code></li>\n<li>出现故障时， <code>数据不会丢失</code> ，但如果  <code>系统尚未将数据 重建到热备用磁盘上</code> ，而此时  <code>又有一个磁盘出现故障</code> ，那么阵列中的  <code>所有数据都将丢失</code></li>\n</ul>\n<h4 id=\"应用-6\"><a class=\"anchor\" href=\"#应用-6\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 5 + Spare</code>  的优点：在系统将  <code>数据重建至备用磁盘时用户仍可以继续访问数据</code></li>\n<li><code>RAID 5 + Spare</code>  能  <code>提供良好的数据安全</code> ，但  <code>磁盘空间由于热备用磁盘的存在</code> （在其他磁盘出现故障之后才使用）而  <code>受到限制</code></li>\n<li><code>RAID 5 + Spare</code>  会使用  <code>热备用磁盘对自己进行重建</code> ，但  <code>故障磁盘还是应尽快更换</code></li>\n</ul>\n<h4 id=\"容量-6\"><a class=\"anchor\" href=\"#容量-6\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 5 + Spare 可用容量</code>  = (  <code>磁盘数</code>  -  <code>2</code>  ) *  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-6\"><a class=\"anchor\" href=\"#raid-6\">#</a> RAID 6</h1>\n<h4 id=\"介绍-7\"><a class=\"anchor\" href=\"#介绍-7\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 6</code>  的数据会在  <code>所有磁盘间进行分条</code> ，并且  <code>每个数据块</code>  的  <code>两个奇偶校验块</code>  写入到  <code>同一条带</code>  上</li>\n<li><code>RAID 6</code>   <code>至少需要四个磁盘</code></li>\n<li>如果  <code>一个磁盘出现故障</code> ，该磁盘上的  <code>数据可以重建到更换磁盘</code>  上</li>\n<li><code>RAID 6</code>   <code>最多允许两个磁盘出故障</code>  而  <code>不丢失数据</code> ，而且它能  <code>更快地重建故障磁盘上的数据</code></li>\n</ul>\n<h4 id=\"应用-7\"><a class=\"anchor\" href=\"#应用-7\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 6</code>  能  <code>进行有效的重建</code> ， <code>确保了数据的可靠性</code></li>\n<li><code>安全性要求较高</code>  且对  <code>性能要求不高</code>  可以选择  <code>RAID 6</code></li>\n</ul>\n<h4 id=\"容量-7\"><a class=\"anchor\" href=\"#容量-7\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 6 可用容量</code>  = (  <code>磁盘数</code>  -  <code>2</code>  ) *  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-0-1\"><a class=\"anchor\" href=\"#raid-0-1\">#</a> RAID 0 + 1</h1>\n<h4 id=\"介绍-8\"><a class=\"anchor\" href=\"#介绍-8\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 0 + 1</code>  是一种  <code>安全</code>  的  <code>RAID 模式</code> ， <code>由条带集的镜像组成</code></li>\n<li><code>RAID 0 + 1</code>  的  <code>磁盘数 为 四的倍数</code></li>\n<li>在  <code>RAID 0 + 1</code>  中， <code>五个磁盘 的 第五个磁盘</code>  将成为  <code>备用磁盘</code>  或  <code>空置磁盘</code></li>\n<li>在  <code>RAID 0 + 1</code>  中， <code>最多允许两个磁盘出现故障</code>  而  <code>不会丢失数据</code> ，但故障磁盘  <code>必须属于同一 RAID 0 队列</code></li>\n</ul>\n<h4 id=\"应用-8\"><a class=\"anchor\" href=\"#应用-8\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 0+1</code>  使用  <code>RAID 0 条带技术</code>  来  <code>提供良好的速度</code> ，但设备的  <code>可用容量会减少一半</code></li>\n</ul>\n<h4 id=\"容量-8\"><a class=\"anchor\" href=\"#容量-8\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 0 + 1 可用容量</code>  =  <code>磁盘数</code>  *  <code>磁盘容量</code>  /  <code>2</code></li>\n</ul>\n<hr />\n<h1 id=\"raid-10\"><a class=\"anchor\" href=\"#raid-10\">#</a> RAID 10</h1>\n<h4 id=\"介绍-9\"><a class=\"anchor\" href=\"#介绍-9\">#</a> 介绍：</h4>\n<ul>\n<li><code>RAID 10</code> （也称为  <code>RAID 1 + 0</code> ）是合并了其他级别（尤其是  <code>RAID 1</code>  和  <code>RAID 0</code> ）特点的另一种 RAID 级别</li>\n<li><code>RAID 10</code>  是一种  <code>镜像集条带</code> ，意思是  <code>数据在两个镜像阵列间分条</code></li>\n<li><code>条带化</code>  在阵列之间发生，而  <code>镜像</code>  是  <code>在相同的阵列中出现</code> ， <code>两种技术的组合加快了重建的速度</code></li>\n<li><code>RAID 10</code>  的  <code>磁盘数 为 四的倍数</code></li>\n<li>在  <code>RAID 10</code>  中， <code>五个磁盘 的 第五个磁盘</code>  将成为  <code>备用磁盘</code>  或  <code>空置磁盘</code></li>\n<li>在  <code>RAID 10</code>  中， <code>每个镜像</code>  对中  <code>可以有一个磁盘出现故障</code>  而  <code>不丢失数据</code></li>\n<li>故障磁盘  <code>所在阵列的磁盘会成为整个阵列中的弱点</code></li>\n<li>如果  <code>镜像</code>  对中的  <code>另一个磁盘也发生故障</code> ，则  <code>会丢失整个阵列</code></li>\n</ul>\n<h4 id=\"应用-9\"><a class=\"anchor\" href=\"#应用-9\">#</a> 应用：</h4>\n<ul>\n<li><code>RAID 10</code>  使用  <code>RAID 0</code>   <code>条带技术</code>  来  <code>提供良好的速度</code> ，但设备的  <code>可用容量会减少一半</code></li>\n</ul>\n<h4 id=\"容量-9\"><a class=\"anchor\" href=\"#容量-9\">#</a> 容量：</h4>\n<ul>\n<li><code>RAID 10 可用容量</code>  =  <code>磁盘数</code>  *  <code>磁盘容量</code>  /  <code>2</code></li>\n</ul>\n<hr />\n<h1 id=\"串联\"><a class=\"anchor\" href=\"#串联\">#</a> 串联</h1>\n<h4 id=\"介绍-10\"><a class=\"anchor\" href=\"#介绍-10\">#</a> 介绍：</h4>\n<ul>\n<li>磁盘  <code>串联</code>  时，其  <code>容量</code>  将会  <code>合并</code> ，并且数据会写入阵列中的主磁盘，主磁盘写满后再写入下一个磁盘</li>\n<li><code>串联</code>   <code>无性能优势</code> ，也  <code>不能增加数据安全措施</code></li>\n<li><code>串联</code>  只是  <code>扩大总容量</code>  而将  <code>两个磁盘组合为一个卷</code>  的方法</li>\n<li>通过  <code>串联可以完全使用阵列</code>  中  <code>所有磁盘的容量</code> ，并且在磁盘发生故障时  <code>大部分数据都可以保存下来</code></li>\n<li>只有  <code>故障磁盘上的数据</code>  、 <code>部分写入故障磁盘</code>  和  <code>作业磁盘的数据才会丢失</code></li>\n</ul>\n<h4 id=\"容量-10\"><a class=\"anchor\" href=\"#容量-10\">#</a> 容量：</h4>\n<ul>\n<li><code>串联可用容量</code>  =  <code>磁盘数</code>  *  <code>磁盘容量</code></li>\n</ul>\n<hr />\n<h1 id=\"jbod\"><a class=\"anchor\" href=\"#jbod\">#</a> JBOD</h1>\n<h4 id=\"介绍-11\"><a class=\"anchor\" href=\"#介绍-11\">#</a> 介绍：</h4>\n<ul>\n<li><code>JBOD</code>  代表  <code>简单磁盘捆绑</code></li>\n<li>阵列中的  <code>每个磁盘</code> ，无论是属于  <code>不同设备</code>  还是  <code>同一设备</code> ，都会作为  <code>单独的磁盘</code>  安装在计算机上</li>\n</ul>\n<h4 id=\"容量-11\"><a class=\"anchor\" href=\"#容量-11\">#</a> 容量：</h4>\n<ul>\n<li><code>JBOD可用容量</code>  =  <code>磁盘数</code>  *  <code>磁盘容量</code></li>\n</ul>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/compress_json_data/",
            "url": "https://byx.vercel.app/note/program/csharp/compress_json_data/",
            "title": "C# 压缩json数据",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static void Main() &#123;\n    string json_data &#x3D; &quot;假装json数据&quot;;\n    &#x2F;&#x2F; 压缩 json 数据\n    string json_data &#x3D; JsonCompress(json_data);\n&#125;\n\npublic static string JsonCompress(string json)\n&#123;\n    StringBuilder sb &#x3D; new StringBuilder();\n    using (StringReader reader &#x3D; new StringReader(json))\n    &#123;\n        int ch &#x3D; -1;\n        int lastch &#x3D; -1;\n        bool isQuoteStart &#x3D; false;\n        while ((ch &#x3D; reader.Read()) &gt; -1)\n        &#123;\n            if ((char)lastch !&#x3D; &#39;\\\\&#39; &amp;&amp; (char)ch &#x3D;&#x3D; &#39;\\&quot;&#39;)\n            &#123;\n                if (!isQuoteStart) isQuoteStart &#x3D; true;\n                else isQuoteStart &#x3D; false;\n            &#125;\n            if (!Char.IsWhiteSpace((char)ch) || isQuoteStart) sb.Append((char)ch);\n            lastch &#x3D; ch;\n        &#125;\n    &#125;\n    return sb.ToString();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/get_the_number_of_system_bits/",
            "url": "https://byx.vercel.app/note/program/csharp/get_the_number_of_system_bits/",
            "title": "C# 获取系统位数",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">if (Environment.Is64BitOperatingSystem) &#123;\n    Console.WriteLine(&quot;64 位系统&quot;);\n&#125; else &#123;\n    Console.WriteLine(&quot;32 位系统&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/get_the_resolution_of_the_monitor/",
            "url": "https://byx.vercel.app/note/program/csharp/get_the_resolution_of_the_monitor/",
            "title": "C# 获取显示器分辨率",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; 获取：显示器分辨率的宽度\nint width &#x3D; Screen.PrimaryScreen.Bounds.Width;\n&#x2F;&#x2F; 获取：显示器分辨率的高度\nint height &#x3D; Screen.PrimaryScreen.Bounds.Height;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/serialize_and_deserialize_yaml/",
            "url": "https://byx.vercel.app/note/program/csharp/serialize_and_deserialize_yaml/",
            "title": "C# 读取和使用 yaml",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\nusing System.IO;\nusing YamlDotNet.Serialization;\n\nnamespace Test\n&#123;\n    public class Test\n    &#123;\n        static void Main()\n        &#123;\n            &#x2F;&#x2F; 读取\n            string str &#x3D; File.ReadAllText(&quot;cat.yaml&quot;);\n            Animal cat &#x3D; new DeserializerBuilder().Build().Deserialize&lt;Animal&gt;(str);\n            Console.WriteLine(cat.name);\n            \n            &#x2F;&#x2F; 写入\n            string str2 &#x3D; new SerializerBuilder().Build().Serialize(cat);\n            Console.WriteLine(str2);\n        &#125;\n    &#125;\n\n    public class Animal\n    &#123;\n        public string name &#123; get; set; &#125;\n        public int age &#123; get; set; &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/set_textbox_to_multiline_text/",
            "url": "https://byx.vercel.app/note/program/csharp/set_textbox_to_multiline_text/",
            "title": "C# 设置 TextBox 为多行文本",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; 设置 TextBox 为多行文本\nTextBox.AcceptsReturn &#x3D; true;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        },
        {
            "id": "https://byx.vercel.app/note/program/csharp/use_zip_to_compress_files_and_folders/",
            "url": "https://byx.vercel.app/note/program/csharp/use_zip_to_compress_files_and_folders/",
            "title": "C# 使用 zip 压缩文件和文件夹",
            "date_published": "2019-08-18T07:35:56.000Z",
            "content_html": "<p><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using ICSharpCode.SharpZipLib.Checksum;\nusing ICSharpCode.SharpZipLib.Zip;\n\nnamespace Test\n&#123;\n    static void Main() &#123;\n        &#x2F;&#x2F; 打包为 zip\n        Zip(@&quot;C:\\打包的路径&quot;, @&quot;D:\\目标路径的zip文件.zip&quot;);\n    &#125;\n\n    public static void Zip(string folderToZip, string zipedFile)\n    &#123;\n        ZipOutputStream zipStream &#x3D; new ZipOutputStream(File.Create(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + @&quot;\\&quot; + zipedFile));\n        &#x2F;&#x2F; 设置压缩率\n        &#x2F;&#x2F; zipStream.SetLevel(4);\n        ZipDirectory(folderToZip, zipStream);\n        zipStream.Finish();\n        zipStream.Close();\n    &#125;\n\n    public static void ZipDirectory(string folderToZip, ZipOutputStream zipStream)\n    &#123;\n        string[] folders, files;\n        FileStream fs &#x3D; null;\n        Crc32 crc &#x3D; new Crc32();\n\n        files &#x3D; Directory.GetFiles(folderToZip);\n        foreach (string file in files)\n        &#123;\n            fs &#x3D; File.OpenRead(file);\n            byte[] buffer &#x3D; new byte[fs.Length];\n            fs.Read(buffer, 0, buffer.Length);\n            ZipEntry ent &#x3D; new ZipEntry(file.Replace(Path.GetDirectoryName(root_dir) + @&quot;\\&quot;, &quot;&quot;));\n            ent.DateTime &#x3D; DateTime.Now;\n            ent.Size &#x3D; fs.Length;\n            fs.Close();\n            crc.Reset();\n            crc.Update(buffer);\n            ent.Crc &#x3D; crc.Value;\n            zipStream.PutNextEntry(ent);\n            zipStream.Write(buffer, 0, buffer.Length);\n        &#125;\n        if (fs !&#x3D; null)\n        &#123;\n            fs.Close();\n            fs.Dispose();\n        &#125;\n        GC.Collect();\n        GC.Collect(1);\n\n        folders &#x3D; Directory.GetDirectories(folderToZip);\n        foreach (string folder in folders)\n        &#123;\n            ZipDirectory(folder, zipStream);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n",
            "tags": [
                "编程",
                "C#"
            ]
        }
    ]
}